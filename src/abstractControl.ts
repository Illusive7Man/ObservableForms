import {BehaviorSubject, fromEvent, merge, Observable, of, Subject, Subscription} from "rxjs";
import {findCachedElement, removeFromCache} from "./common/cache";
import {delay, distinctUntilChanged, filter, map, share, startWith, switchMap} from "rxjs/operators";
import {Instance} from "@popperjs/core";
import {FormControlStatus, ValidationErrors, ValidatorFn} from "./common/types";
import {validationEnabled} from "./common/decorators";

/**
 * This is the base class for `FormControl` and `FormGroup`.
 *
 * It provides some of the shared behavior that all controls and groups of controls have, like
 * running validators, calculating status, and resetting state. It also defines the properties
 * that are shared between all sub-classes, like `value`, `valid`, and `dirty`. It shouldn't be
 * instantiated directly.
 *
 * @publicApi
 */
export abstract class AbstractControl {

    /**
     * Synchronous validators as they were provided:
     *  - in `AbstractControl` constructor
     *  - as an argument while calling `setValidators` function
     *  - while calling the setter on the `validator` field (e.g. `control.validator = validatorFn`)
     */
    protected validators: ValidatorFn[];

    /**
     * The current value of the control.
     *
     * * For a `FormControl`, the current value.
     * * For an enabled `FormGroup`, the values of enabled controls as an object
     * with a key-value pair for each member of the group.
     * * For a disabled `FormGroup`, the values of all controls as an object
     * with a key-value pair for each member of the group.
     */
    public readonly value: any;

    constructor(protected jQueryObject: JQuery) {}

    /**
     * Subject for emitting  dirty / pristine state.
     *
     */
    protected dirtySubject: Subject<boolean>;
    /**
     * Subject for emitting  touched / untouched state.
     *
     */
    protected touchedSubject: Subject<boolean>;
    /**
     * Subject for emitting  disabled / enabled state.
     */
    protected disabledSubject: Subject<boolean>;

    /**
     * Subject for emitting  whether field is of type hidden or not.
     */
    protected hiddenSubject: Subject<boolean>;

    /**
     * The validation status of the control. There are four possible
     * validation status values:
     *
     * * **VALID**: This control has passed all validation checks.
     * * **INVALID**: This control has failed at least one validation check.
     * * **PENDING**: This control is in the midst of conducting a validation check.
     * * **DISABLED**: This control is exempt from validation checks.
     *
     * These status values are mutually exclusive, so a control cannot be
     * both valid AND invalid or invalid AND disabled.
     */
    public readonly status: FormControlStatus;

    /**
     * A control is `valid` when its `status` is `VALID`.
     *
     * @see {@link AbstractControl.status}
     *
     * @returns True if the control has passed all of its validation tests,
     * false otherwise.
     */
    get valid(): boolean {
        return this.status === FormControlStatus.VALID;
    }

    /**
     * A control is `invalid` when its `status` is `INVALID`.
     *
     * @see {@link AbstractControl.status}
     *
     * @returns True if this control has failed one or more of its validation checks,
     * false otherwise.
     */
    get invalid(): boolean {
        return this.status === FormControlStatus.INVALID;
    }

    /**
     * A control is `disabled` when its `status` is `DISABLED`.
     *
     * Disabled controls are exempt from validation checks and
     * are not included in the aggregate value of their ancestor
     * controls.
     *
     * @see {@link AbstractControl.status}
     *
     * @returns True if the control is disabled, false otherwise.
     */
    get disabled(): boolean {
        return this.status ? this.status === FormControlStatus.DISABLED : this.toJQuery()[0]?.hasAttribute('disabled');
    }

    /**
     * A control is `enabled` as long as its `status` is not `DISABLED`.
     *
     * @returns True if the control has any status other than 'DISABLED',
     * false if the status is 'DISABLED'.
     *
     * @see {@link AbstractControl.status}
     *
     */
    get enabled(): boolean {
        return this.status ? this.status !== FormControlStatus.DISABLED : !this.toJQuery()[0]?.hasAttribute('disabled');
    }

    /**
     * An object containing any errors generated by failing validation,
     * or null if there are no errors.
     */
    public readonly errors: ValidationErrors;

    /**
     * A control is `pristine` if the user has not yet changed
     * the value in the UI.
     *
     * @returns True if the user has not yet changed the value in the UI; compare `dirty`.
     * Programmatic changes to a control's value do not mark it dirty.
     */
    public readonly pristine: boolean = true;

    /**
     * A control is `dirty` if the user has changed the value
     * in the UI.
     *
     * @returns True if the user has changed the value of this control in the UI; compare `pristine`.
     * Programmatic changes to a control's value do not mark it dirty.
     */
    get dirty(): boolean {
        return !this.pristine;
    }

    /**
     * True if the control is marked as `touched`.
     *
     * A control is marked `touched` once the user has triggered
     * a `blur` event on it.
     */
    public readonly touched: boolean = false;

    /**
     * True if the control has not been marked as touched
     *
     * A control is `untouched` if the user has not yet triggered
     * a `blur` event on it.
     */
    get untouched(): boolean {
        return !this.touched;
    }

    /**
     * A multicasting observable that emits an event every time the value of the control changes, in
     * the UI or programmatically. It also emits an event each time you call enable() or disable()
     * without passing along {emitEvent: false} as a function argument.
     */
    public readonly valueChanges!: Observable<any>;
    protected valueChangesSubject: Subject<any>;
    /**
     * Applies provided mapping function to the calculated value of the control / group.
     * @param mapFn Function that maps from the calculated value to the new value.
     */
    protected valueMapFn: (value: any) => any;

    /**
     * A multicasting observable that emits an event every time the validation `status` of the control
     * recalculates.
     *
     * @see {@link AbstractControl.status}
     */
    public readonly statusChanges!: Observable<FormControlStatus>;

    readonly isValidationEnabled: boolean = false;
    protected manualValidityUpdateSubject: Subject<void>;
    protected _existingValidationSubscription: Subscription;

    validityPopper: Instance;
    /**
     * Indicates whether validation errors are currently shown to the user.
     *
     */
    isValidityMessageShown$: Observable<boolean>;

    /**
     * Gets the synchronous validators that are active on this control.
     */
    getValidators(): ValidatorFn[] | null {
        return this.validators ?? null;
    }

    /**
     * Sets the synchronous validators that are active on this control.  Calling
     * this overwrites any existing sync validators.
     */
    setValidators(newValidators: ValidatorFn[]): void {
        this.validators = newValidators;
        this.updateValidity();
    }

    /**
     * Empties out the sync validator list.
     */
    clearValidators(): void {
        this.validators = null;
        this.updateValidity();
    }

    /**
     * Marks the control as `touched`. A control is touched by focus and
     * blur events that do not change the value.
     *
     * @see `markAsUntouched()`
     * @see `markAsDirty()`
     * @see `markAsPristine()`
     */
    markAsTouched(): void {
        (this as {touched: boolean}).touched = true;
        this.touchedSubject.next(true);
    }


    markAllAsTouched(): void {
        this.markAsTouched();
    }

    /**
     * Marks the control as `untouched`.
     *
     * If the control has any children, also marks all children as `untouched`
     * and recalculates the `touched` status of all parent controls.
     *
     * @see `markAsTouched()`
     * @see `markAsDirty()`
     * @see `markAsPristine()`
     */
    markAsUntouched(opts: {onlySelf?: boolean} = {}): void {
        (this as {touched: boolean}).touched = false;
        this.touchedSubject.next(false);
    }

    /**
     * Marks the control as `dirty`. A control becomes dirty when
     * the control's value is changed through the UI; compare `markAsTouched`.
     *
     * @see `markAsTouched()`
     * @see `markAsUntouched()`
     * @see `markAsPristine()`
     */
    markAsDirty(opts: {onlySelf?: boolean} = {}): void {
        (this as {pristine: boolean}).pristine = false;
        this.dirtySubject.next(true);
    }

    /**
     * Marks the control and all its descendant controls as `dirty`.
     * @see `markAsTouched()`
     */
        markAllAsDirty(): void {
        this.markAsDirty();
    }

    /**
     * Marks the control as `pristine`.
     *
     * If the control has any children, marks all children as `pristine`,
     * and recalculates the `pristine` status of all parent
     * controls.
     *
     * @see `markAsTouched()`
     * @see `markAsUntouched()`
     * @see `markAsDirty()`
     * marks all direct ancestors. Default is false.
     */
    markAsPristine(): void {
        (this as {pristine: boolean}).pristine = true;
        this.dirtySubject.next(false);
    }

    /**
     * Disables the control. This means the control is exempt from validation checks and
     * excluded from the aggregate value of any parent. Its status is `DISABLED`.
     *
     * If the control has children, all children are also disabled.
     *
     * @see {@link AbstractControl.status}
     */
    disable(): void {
        this.toJQuery()[0].setAttribute('disabled', '');
        this.disabledSubject.next(true);
    }

    /**
     * Enables the control. This means the control is included in validation checks and
     * the aggregate value of its parent. Its status recalculates based on its value and
     * its validators.
     *
     * By default, if the control has children, all children are enabled.
     *
     * @see {@link AbstractControl.status}
     */
    enable(): void {
        this.toJQuery()[0].removeAttribute('disabled');
        this.disabledSubject.next(false);
    }

    /**
     * Sets the value of the control. Abstract method (implemented in sub-classes).
     */
    abstract setValue(value: any): void;

    /**
     * Patches the value of the control. Abstract method (implemented in sub-classes).
     */
    abstract patchValue(value: any): void;

    /**
     * Resets the control. Abstract method (implemented in sub-classes).
     */
    abstract reset(): void;

    protected setupObservables(valueChangesUI?: Observable<any>,
                             touchedUI$?: Observable<void>,
                             dirtyUI$?: Observable<void>): void {

        this.valueChangesSubject = new Subject<any>();
        (this as {valueChanges: Observable<any>}).valueChanges = this.valueChangesSubject.asObservable().pipe(   // Subject so it can be triggered
            map(value => this.valueMapFn?.(value) ?? value),                                             // Custom mapping
            distinctUntilChanged(), share());                                                                    // Distinct and shared

        let s = this.valueChanges.subscribe(value => (this as {value: any}).value = value);                // Assign to "value"

        // Touched state
        this.touchedSubject = new Subject<boolean>();
        this.subscriptions = new Subscription();
        this.markAsUntouched();

        // Dirty state
        this.dirtySubject = new Subject<boolean>();
        this.markAsPristine();

        // Disabled subject
        this.disabledSubject = new Subject<boolean>();

        // Hidden subject
        this.hiddenSubject = new Subject<boolean>();

        this.subscriptions.add(s);
    }

    valueMap(mapFn: (value: any) => any): this {
        this.valueMapFn = mapFn;
        return this;
    }

    /**
     * Recalculates the validation status of the control.
     *
     * By default, it also updates the value and validity of its ancestors.
     */
    @validationEnabled
    updateValidity(): void {
        this.manualValidityUpdateSubject.next();
    }


    /**
     * @description
     * Reports whether the control with the given path has the error specified.
     *
     * @param errorCode The code of the error to check
     */
    @validationEnabled
    hasError(errorCode: string): boolean {
        return !!this.errors && Object.keys(this.errors).some(key => key === errorCode);
    }

    logErrors(): void {
        if (this.errors)
            console.log(this.errors);
    }

    toJQuery(): JQuery {
        return this.jQueryObject;
    }

    subscriptions: Subscription;

    /**
     * Stops tracking validity of the field(s) and creates notifications in the UI.
     */
    disableValidation(): void {
        this._existingValidationSubscription.unsubscribe();
        this.manualValidityUpdateSubject.complete();

        this.validityPopper.state.elements.popper.remove();
        this.validityPopper.destroy();

        (this as {isValidationEnabled: boolean}).isValidationEnabled = false;
    }

    destroy(): void {
        // Close observables
        this.valueChangesSubject.complete();
        this.touchedSubject.complete();
        this.dirtySubject.complete();
        // this.controlsArraySubject.complete();
        this.disabledSubject.complete();
        this.hiddenSubject.complete();
        this.subscriptions.unsubscribe();

        removeFromCache(this);

        if (this.isValidationEnabled)
            this.disableValidation();
    }
}

import {BehaviorSubject, Observable, Subject} from "rxjs";
// @ts-ignore
import {JQuery as JQueryOriginal} from '@types/jquery/JQuery';
import {FormControlStatus} from "../validation";


declare global {
    type FormControlType = HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement;
    type ValidationErrors = {
        [key: string]: any;
    };

    interface ValidatorFn {
        (formControl: JQuery<FormControlType | HTMLFormElement>): ValidationErrors | null;
    }

    abstract class JQuery<TElement = HTMLElement> implements JQueryOriginal<FormControlType> {

        /**
         * Manually converts the jquery object to a form control.
         * Used when selecting objects using methods and not the constructor (children, find...),
         * or when the constructor hasn't returned any results.
         *
         */
        convertToFormControl(): JQuery<FormControlType | HTMLFormElement>;
        /**
         * @description
         * Reports whether the control is valid. A control is considered valid if no
         * validation errors exist with the current value.
         * If the control is not present, null is returned.
         */
        readonly valid: boolean | null;
        /**
         * @description
         * Reports whether the control is invalid, meaning that an error exists in the input value.
         * If the control is not present, null is returned.
         */
        readonly invalid: boolean | null;
        /**
         * A control is `disabled` when its `status` is `DISABLED`.
         *
         * Disabled controls are exempt from validation checks and
         * are not included in the aggregate value of their ancestor
         * controls.
         *
         * @see {@link AbstractControl.status}
         *
         * @returns True if the control is disabled, false otherwise.
         */
        readonly disabled: boolean;
        /**
         * A control is `enabled` as long as its `status` is not `DISABLED`.
         *
         * @returns True if the control has any status other than 'DISABLED',
         * false if the status is 'DISABLED'.
         *
         * @see {@link AbstractControl.status}
         *
         */
        readonly enabled: boolean;
        /**
         * An object containing any errors generated by failing validation,
         * or null if there are no errors.
         */
        readonly errors: ValidationErrors | null;
        /**
         * A control is `pristine` if the user has not yet changed
         * the value in the UI.
         *
         * @returns True if the user has not yet changed the value in the UI; compare `dirty`.
         * Programmatic changes to a control's value do not mark it dirty.
         */
        readonly pristine: boolean;
        /**
         * A control is `dirty` if the user has changed the value
         * in the UI.
         *
         * @returns True if the user has changed the value of this control in the UI; compare `pristine`.
         * Programmatic changes to a control's value do not mark it dirty.
         */
        readonly dirty: boolean;
        /**
         * True if the control is marked as `touched`.
         *
         * A control is marked `touched` once the user has triggered
         * a `blur` event on it.
         */
        readonly touched: boolean;
        /**
         * True if the control has not been marked as touched
         *
         * A control is `untouched` if the user has not yet triggered
         * a `blur` event on it.
         */
        readonly untouched: boolean;
        /**
         * The validation status of the control. There are four possible
         * validation status values:
         *
         * * **VALID**: This control has passed all validation checks.
         * * **INVALID**: This control has failed at least one validation check.
         * * **PENDING**: This control is in the midst of conducting a validation check.
         * * **DISABLED**: This control is exempt from validation checks.
         *
         * These status values are mutually exclusive, so a control cannot be
         * both valid AND invalid or invalid AND disabled.
         */
        readonly status: FormControlStatus;
        /**
         * A multicasting observable that emits an event every time the value of the control changes, in
         * the UI or programmatically.
         */
        readonly valueChanges: Observable<any>;
        /**
         * A multicasting observable that emits an event every time the validation `status` of the control
         * recalculates.
         *
         * @see {@link AbstractControl.status}
         *
         */
        readonly statusChanges: Observable<FormControlStatus>;
        readonly statusChangesSubject: Subject<FormControlStatus>;
        /**
         * Starts tracking validity of the field(s) and creates notifications in the UI.
         *
         * @param opts Configuration options that determine how the control propagates changes
         * and emits events after the marking is applied.
         * * `onlySelf`: When true, validate only this control. When false or not supplied,
         * validate all ancestors. Default is false.
         */
        enableValidation(): void;
        /**
         * Stops tracking validity of the field(s) and creates notifications in the UI.
         */
        disableValidation(): void;
        /**
         * Empties out the sync validator list.
         *
         * When you add or remove a validator at run time, you must call
         * `updateValueAndValidity()` for the new validation to take effect.
         *
         */
        clearValidators(): void;

        /**
         * Marks the control as `touched`. A control is touched by focus and
         * blur events that do not change the value.
         *
         * @see `markAsUntouched()`
         * @see `markAsDirty()`
         * @see `markAsPristine()`
         */
        markAsTouched(): void;
        /**
         * Marks the control and all its descendant controls as `touched`.
         * @see `markAsTouched()`
         */
        markAllAsTouched(): void;
        /**
         * Marks the control as `untouched`.
         *
         * If the control has any children, also marks all children as `untouched`
         * and recalculates the `touched` status of all parent controls.
         *
         * @see `markAsTouched()`
         * @see `markAsDirty()`
         * @see `markAsPristine()`
         */
        markAsUntouched(): void;

        /**
         * Marks the control as `dirty`. A control becomes dirty when
         * the control's value is changed through the UI; compare `markAsTouched`.
         *
         * @see `markAsTouched()`
         * @see `markAsUntouched()`
         * @see `markAsPristine()`
         *
         * @param opts Configuration options that determine how the control propagates changes
         * and emits events after marking is applied.
         * * `onlySelf`: When true, mark only this control. When false or not supplied,
         * marks all direct ancestors. Default is false.
         */
        markAsDirty(): void;
        /**
         * Marks the control and all its descendant controls as `dirty`.
         * @see `markAsTouched()`
         */
        markAllAsDirty(): void;
        /**
         * Marks the control as `pristine`.
         *
         * If the control has any children, marks all children as `pristine`,
         * and recalculates the `pristine` status of all parent
         * controls.
         *
         * @see `markAsTouched()`
         * @see `markAsUntouched()`
         * @see `markAsDirty()`
         */
        markAsPristine(): void;

        /**
         * Subject for emitting  dirty / pristine state.
         *
         */
        readonly dirtySubject: Subject<boolean>;
        /**
         * Subject for emitting  touched / untouched state.
         *
         */
        readonly touchedSubject: Subject<boolean>;

        /**
         * Sets the synchronous validators that are active on this control.  Calling
         * this overwrites any existing sync validators.
         *
         * When you add or remove a validator at run time, you must call
         * `updateValueAndValidity()` for the new validation to take effect.
         *
         */
        setValidators(newValidator: ValidatorFn[] | null): void;

        /**
         * Gets the synchronous validators that are active on this control.
         *
         */
        getValidators(): ValidatorFn[] | null;

        protected _validators: ValidatorFn[] | null;

        /**
         * Recalculates the value and validation status of the form element.
         *
         * By default, it also updates the value and validity of its ancestors.
         */
        updateValidity(): void;

        protected _setInitialStatus;
        protected _runValidator;
        protected _runAsyncValidator;
        protected _existingValidationSubscription;
        validityPopper: any;
        /**
         * Indicates whether validation errors are currently shown to the user.
         *
         */
        isValidityMessageShown$: Observable<boolean>;
        /**
         * Resets the element to original value and clear any of its errors.
         */
        reset(): void;
        /**
         * List of selected elements. Useful when selector has multiple results.
         */
        selectedFormControls: JQuery<FormControlType>[];
    }
}

declare namespace JQueryInternal {

    /**
     * Internal usage.
     */
    abstract class JQueryInternal<TElement = HTMLElement> extends JQuery<TElement> {
        /**
         * Set to true on form controls, otherwise undefined.
         */
        isFormControl: boolean;
        valid: boolean | null;
        invalid: boolean | null;
        disabled: boolean;
        enabled: boolean;
        errors: ValidationErrors | null;
        pristine: boolean;
        dirty: boolean;
        touched: boolean;
        untouched: boolean;
        status: FormControlStatus;
        valueChanges: Observable<any>;
        valueChangesSubject: Subject<any>;
        statusChanges: Observable<FormControlStatus>;
        statusChangesSubject: Subject<FormControlStatus>;
        /**
         * Used to programatically update the validity of the form control.
         */
        manualValidityUpdateSubject: Subject<void>;
        dirtySubject: Subject<boolean>;
        touchedSubject: Subject<boolean>;
        _validators: ValidatorFn[] | null;
        public _setInitialStatus;
        public _runValidator;
        public _runAsyncValidator;
        public _existingValidationSubscription;
        selectedFormControls: JQueryInternal<FormControlType>[];
        selectedFormControlsSubject: BehaviorSubject<JQueryInternal<FormControlType>[]>;
        selectedFormControls$: Observable<JQueryInternal<FormControlType>[]>;
    }
}



/**
 * @description
 * Provides a set of built-in validators that can be used by form controls.
 *
 * A validator is a function that processes a `FormControl` or collection of
 * controls and returns an error map or null. A null map means that validation has passed.
 *
 * @see [Form Validation](/guide/form-validation)
 *
 * @publicApi
 */
export declare class Validators {
    /**
     * @description
     * Validator that requires the control's value to be greater than or equal to the provided number.
     * The validator exists only as a function and not as a directive.
     *
     * @usageNotes
     *
     * ### Validate against a minimum of 3
     *
     * ```typescript
     * const control = new FormControl(2, Validators.min(3));
     *
     * console.log(control.errors); // {min: {min: 3, actual: 2}}
     * ```
     *
     * @returns A validator function that returns an error map with the
     * `min` property if the validation check fails, otherwise `null`.
     *
     * @see `updateValueAndValidity()`
     *
     */
    static min(min: number): ValidatorFn;

    /**
     * @description
     * Validator that requires the control's value to be less than or equal to the provided number.
     * The validator exists only as a function and not as a directive.
     *
     * @usageNotes
     *
     * ### Validate against a maximum of 15
     *
     * ```typescript
     * const control = new FormControl(16, Validators.max(15));
     *
     * console.log(control.errors); // {max: {max: 15, actual: 16}}
     * ```
     *
     * @returns A validator function that returns an error map with the
     * `max` property if the validation check fails, otherwise `null`.
     *
     * @see `updateValueAndValidity()`
     *
     */
    static max(max: number): ValidatorFn;

    /**
     * @description
     * Validator that requires the control have a non-empty value.
     *
     * @usageNotes
     *
     * ### Validate that the field is non-empty
     *
     * ```typescript
     * const control = new FormControl('', Validators.required);
     *
     * console.log(control.errors); // {required: true}
     * ```
     *
     * @returns An error map with the `required` property
     * if the validation check fails, otherwise `null`.
     *
     * @see `updateValueAndValidity()`
     *
     */
    static required(control: JQuery<FormControlType | HTMLFormElement>): ValidationErrors | null;

    /**
     * @description
     * Validator that requires the control's value be true. This validator is commonly
     * used for required checkboxes.
     *
     * @usageNotes
     *
     * ### Validate that the field value is true
     *
     * ```typescript
     * const control = new FormControl('', Validators.requiredTrue);
     *
     * console.log(control.errors); // {required: true}
     * ```
     *
     * @returns An error map that contains the `required` property
     * set to `true` if the validation check fails, otherwise `null`.
     *
     * @see `updateValueAndValidity()`
     *
     */
    static requiredTrue(control: JQuery<FormControlType | HTMLFormElement>): ValidationErrors | null;

    /**
     * @description
     * Validator that requires the control's value pass an email validation test.
     *
     * Tests the value using a [regular expression](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions)
     * pattern suitable for common usecases. The pattern is based on the definition of a valid email
     * address in the [WHATWG HTML specification](https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address)
     * with some enhancements to incorporate more RFC rules (such as rules related to domain names and
     * the lengths of different parts of the address).
     *
     * The differences from the WHATWG version include:
     * - Disallow `local-part` (the part before the `@` symbol) to begin or end with a period (`.`).
     * - Disallow `local-part` to be longer than 64 characters.
     * - Disallow the whole address to be longer than 254 characters.
     *
     * If this pattern does not satisfy your business needs, you can use `Validators.pattern()` to
     * validate the value against a different pattern.
     *
     * @usageNotes
     *
     * ### Validate that the field matches a valid email pattern
     *
     * ```typescript
     * const control = new FormControl('bad@', Validators.email);
     *
     * console.log(control.errors); // {email: true}
     * ```
     *
     * @returns An error map with the `email` property
     * if the validation check fails, otherwise `null`.
     *
     * @see `updateValueAndValidity()`
     *
     */
    static email(control: JQuery<FormControlType | HTMLFormElement>): ValidationErrors | null;

    /**
     * @description
     * Validator that requires the length of the control's value to be greater than or equal
     * to the provided minimum length. This validator is also provided by default if you use the
     * the HTML5 `minlength` attribute.
     *
     * @usageNotes
     *
     * ### Validate that the field has a minimum of 3 characters
     *
     * ```typescript
     * const control = new FormControl('ng', Validators.minLength(3));
     *
     * console.log(control.errors); // {minlength: {requiredLength: 3, actualLength: 2}}
     * ```
     *
     * ```html
     * <input minlength="5">
     * ```
     *
     * @returns A validator function that returns an error map with the
     * `minlength` if the validation check fails, otherwise `null`.
     *
     * @see `updateValueAndValidity()`
     *
     */
    static minLength(minLength: number): ValidatorFn;

    /**
     * @description
     * Validator that requires the length of the control's value to be less than or equal
     * to the provided maximum length. This validator is also provided by default if you use the
     * the HTML5 `maxlength` attribute.
     *
     * @usageNotes
     *
     * ### Validate that the field has maximum of 5 characters
     *
     * ```typescript
     * const control = new FormControl('Angular', Validators.maxLength(5));
     *
     * console.log(control.errors); // {maxlength: {requiredLength: 5, actualLength: 7}}
     * ```
     *
     * ```html
     * <input maxlength="5">
     * ```
     *
     * @returns A validator function that returns an error map with the
     * `maxlength` property if the validation check fails, otherwise `null`.
     *
     * @see `updateValueAndValidity()`
     *
     */
    static maxLength(maxLength: number): ValidatorFn;

    /**
     * @description
     * Validator that requires the control's value to match a regex pattern. This validator is also
     * provided by default if you use the HTML5 `pattern` attribute.
     *
     * @usageNotes
     *
     * ### Validate that the field only contains letters or spaces
     *
     * ```typescript
     * const control = new FormControl('1', Validators.pattern('[a-zA-Z ]*'));
     *
     * console.log(control.errors); // {pattern: {requiredPattern: '^[a-zA-Z ]*$', actualValue: '1'}}
     * ```
     *
     * ```html
     * <input pattern="[a-zA-Z ]*">
     * ```
     *
     * @param pattern A regular expression to be used as is to test the values, or a string.
     * If a string is passed, the `^` character is prepended and the `$` character is
     * appended to the provided string (if not already present), and the resulting regular
     * expression is used to test the values.
     *
     * @returns A validator function that returns an error map with the
     * `pattern` property if the validation check fails, otherwise `null`.
     *
     * @see `updateValueAndValidity()`
     *
     */
    static pattern(pattern: string | RegExp): ValidatorFn;

    /**
     * @description
     * Validator that performs no operation.
     *
     * @see `updateValueAndValidity()`
     *
     */
    static nullValidator(control: JQuery<FormControlType | HTMLFormElement>): ValidationErrors | null;

    /**
     * @description
     * Compose multiple validators into a single function that returns the union
     * of the individual error maps for the provided control.
     *
     * @returns A validator function that returns an error map with the
     * merged error maps of the validators if the validation check fails, otherwise `null`.
     *
     * @see `updateValueAndValidity()`
     *
     */
    static compose(validators: null): null;
    static compose(validators: (ValidatorFn | null | undefined)[]): ValidatorFn | null;

}
